CCS PCM C Compiler, Version 5.015, 5967               03-may.-20 23:45

               Filename:   C:\Microcontroladores\P5-L\p5.lst

               ROM used:   221 words (3%)
                           Largest free fragment is 2048
               RAM used:   8 (2%) at main() level
                           8 (2%) worst case
               Stack used: 1 locations
               Stack size: 8

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   019
0003:  NOP
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
....................  
.................... #list 
....................  
.................... #device ADC=8 
.................... #fuses INTRC_IO,NOWDT,NOPROTECT,NOLVP, NOMCLR, NOCPD, NOBROWNOUT, NODEBUG, NOLVP, NOIESO, NOFCMEN 
.................... #use delay(clock=4000000) 
0004:  MOVLW  22
0005:  MOVWF  04
0006:  BCF    03.7
0007:  MOVF   00,W
0008:  BTFSC  03.2
0009:  GOTO   018
000A:  MOVLW  01
000B:  MOVWF  78
000C:  CLRF   77
000D:  DECFSZ 77,F
000E:  GOTO   00D
000F:  DECFSZ 78,F
0010:  GOTO   00C
0011:  MOVLW  4A
0012:  MOVWF  77
0013:  DECFSZ 77,F
0014:  GOTO   013
0015:  GOTO   016
0016:  DECFSZ 00,F
0017:  GOTO   00A
0018:  RETURN
....................  
.................... void main(){ 
0019:  MOVF   03,W
001A:  ANDLW  1F
001B:  MOVWF  03
001C:  MOVLW  61
001D:  BSF    03.5
001E:  MOVWF  0F
001F:  MOVF   0F,W
0020:  MOVLW  FF
0021:  BCF    03.5
0022:  MOVWF  20
0023:  BSF    03.5
0024:  BSF    03.6
0025:  MOVF   09,W
0026:  ANDLW  C0
0027:  MOVWF  09
0028:  BCF    03.6
0029:  BCF    1F.4
002A:  BCF    1F.5
002B:  MOVLW  00
002C:  BSF    03.6
002D:  MOVWF  08
002E:  BCF    03.5
002F:  CLRF   07
0030:  CLRF   08
0031:  CLRF   09
0032:  BCF    03.7
.................... 	int8 valor;  
.................... 	 
.................... 	setup_ccp1(CCP_PWM);				//Se configura el modulo CCP1 en modo PWM 
0033:  BCF    03.6
0034:  BCF    20.2
0035:  MOVF   20,W
0036:  BSF    03.5
0037:  MOVWF  07
0038:  BCF    03.5
0039:  BCF    07.2
003A:  MOVLW  0C
003B:  MOVWF  17
003C:  BSF    03.5
003D:  CLRF   1B
003E:  CLRF   1C
003F:  MOVLW  01
0040:  MOVWF  1D
.................... 	setup_ccp2(CCP_PWM);				//Se configura el modulo CCP2 en modo PWM 
0041:  BCF    03.5
0042:  BCF    20.1
0043:  MOVF   20,W
0044:  BSF    03.5
0045:  MOVWF  07
0046:  BCF    03.5
0047:  BCF    07.1
0048:  MOVLW  0C
0049:  MOVWF  1D
....................  
.................... 	setup_timer_2(T2_DIV_BY_16, 250, 1); 
004A:  MOVLW  00
004B:  MOVWF  78
004C:  IORLW  06
004D:  MOVWF  12
004E:  MOVLW  FA
004F:  BSF    03.5
0050:  MOVWF  12
....................  
.................... 	set_pwm1_duty(0);					//Se fija el ciclo de trabajo de 0% en CCP1 y CCP2 
0051:  BCF    03.5
0052:  CLRF   15
.................... 	set_pwm2_duty(0); 
0053:  CLRF   1B
....................  
.................... 	setup_adc_ports(sAN0,sAN1);			//Configuración del ADC 
0054:  BSF    03.5
0055:  BSF    03.6
0056:  MOVF   09,W
0057:  ANDLW  C0
0058:  MOVWF  09
0059:  BCF    03.6
005A:  BCF    1F.4
005B:  BCF    1F.5
005C:  MOVLW  03
005D:  BSF    03.6
005E:  MOVWF  08
.................... 	setup_adc(ADC_CLOCK_INTERNAL); 
005F:  BCF    03.5
0060:  BCF    03.6
0061:  BSF    1F.6
0062:  BSF    1F.7
0063:  BSF    03.5
0064:  BCF    1F.7
0065:  BCF    03.5
0066:  BSF    1F.0
....................  
.................... 	while( TRUE ){ 
.................... 		//Control de velocidad y sentido del Motor 1 
.................... 		set_adc_channel(0); 			//Seleccionar AN0 como entrada del ADC 
0067:  MOVLW  00
0068:  MOVWF  78
0069:  MOVF   1F,W
006A:  ANDLW  C3
006B:  IORWF  78,W
006C:  MOVWF  1F
.................... 		delay_ms(10);					//Retardo necesario para la conversión 
006D:  MOVLW  0A
006E:  MOVWF  22
006F:  CALL   004
.................... 		valor = read_adc();				//Iniciar lectura del ADC 
0070:  BSF    1F.1
0071:  BTFSC  1F.1
0072:  GOTO   071
0073:  MOVF   1E,W
0074:  MOVWF  21
....................  
.................... 		if(valor > 127){ 
0075:  MOVF   21,W
0076:  SUBLW  7F
0077:  BTFSC  03.0
0078:  GOTO   08E
.................... 			valor = (valor-128)*2;		//Calcular el ciclo de trabajo 
0079:  MOVLW  80
007A:  SUBWF  21,W
007B:  MOVWF  77
007C:  BCF    03.0
007D:  RLF    77,W
007E:  MOVWF  21
.................... 			set_pwm1_duty(valor);		//Fijar el ciclo del trabajo 
007F:  MOVF   21,W
0080:  MOVWF  15
.................... 			output_high(PIN_C0);		//Girar en sentido horario 
0081:  BCF    20.0
0082:  MOVF   20,W
0083:  BSF    03.5
0084:  MOVWF  07
0085:  BCF    03.5
0086:  BSF    07.0
.................... 			output_low(PIN_C3); 
0087:  BCF    20.3
0088:  MOVF   20,W
0089:  BSF    03.5
008A:  MOVWF  07
008B:  BCF    03.5
008C:  BCF    07.3
.................... 		}else{ 
008D:  GOTO   0A1
.................... 			valor*=2; 
008E:  BCF    03.0
008F:  RLF    21,F
.................... 			valor= 254-valor;			//Calcular el ciclo de trabajo 
0090:  MOVF   21,W
0091:  SUBLW  FE
0092:  MOVWF  21
.................... 			set_pwm1_duty(valor);		//Fijar el ciclo del trabajo 
0093:  MOVF   21,W
0094:  MOVWF  15
.................... 			output_low(PIN_C0);		    //Girar en sentido antihorario 
0095:  BCF    20.0
0096:  MOVF   20,W
0097:  BSF    03.5
0098:  MOVWF  07
0099:  BCF    03.5
009A:  BCF    07.0
.................... 			output_high(PIN_C3); 
009B:  BCF    20.3
009C:  MOVF   20,W
009D:  BSF    03.5
009E:  MOVWF  07
009F:  BCF    03.5
00A0:  BSF    07.3
.................... 		}	 
....................  
.................... 		//Control de velocidad y sentido del Motor 2 
.................... 		set_adc_channel(1); 			//Seleccionar AN1 como entrada del ADC 
00A1:  MOVLW  04
00A2:  MOVWF  78
00A3:  MOVF   1F,W
00A4:  ANDLW  C3
00A5:  IORWF  78,W
00A6:  MOVWF  1F
.................... 		delay_ms(10);					//Retardo necesario para la conversión 
00A7:  MOVLW  0A
00A8:  MOVWF  22
00A9:  CALL   004
.................... 		valor = read_adc();				//Iniciar lectura del ADC 
00AA:  BSF    1F.1
00AB:  BTFSC  1F.1
00AC:  GOTO   0AB
00AD:  MOVF   1E,W
00AE:  MOVWF  21
.................... 		 
.................... 		if(valor > 127){ 
00AF:  MOVF   21,W
00B0:  SUBLW  7F
00B1:  BTFSC  03.0
00B2:  GOTO   0C8
.................... 			valor = (valor-128)*2;		//Calcular el ciclo de trabajo 
00B3:  MOVLW  80
00B4:  SUBWF  21,W
00B5:  MOVWF  77
00B6:  BCF    03.0
00B7:  RLF    77,W
00B8:  MOVWF  21
.................... 			set_pwm2_duty(valor);		//Fijar el ciclo del trabajo 
00B9:  MOVF   21,W
00BA:  MOVWF  1B
.................... 			output_high(PIN_C4);		//Girar en sentido horario 
00BB:  BCF    20.4
00BC:  MOVF   20,W
00BD:  BSF    03.5
00BE:  MOVWF  07
00BF:  BCF    03.5
00C0:  BSF    07.4
.................... 			output_low(PIN_C5); 
00C1:  BCF    20.5
00C2:  MOVF   20,W
00C3:  BSF    03.5
00C4:  MOVWF  07
00C5:  BCF    03.5
00C6:  BCF    07.5
.................... 		}else{ 
00C7:  GOTO   0DB
.................... 			valor*=2; 
00C8:  BCF    03.0
00C9:  RLF    21,F
.................... 			valor= 254-valor;			//Calcular el ciclo de trabajo 
00CA:  MOVF   21,W
00CB:  SUBLW  FE
00CC:  MOVWF  21
.................... 			set_pwm2_duty(valor);		//Fijar el ciclo del trabajo 
00CD:  MOVF   21,W
00CE:  MOVWF  1B
.................... 			output_low(PIN_C4);		//Girar en sentido antihorario 
00CF:  BCF    20.4
00D0:  MOVF   20,W
00D1:  BSF    03.5
00D2:  MOVWF  07
00D3:  BCF    03.5
00D4:  BCF    07.4
.................... 			output_high(PIN_C5); 
00D5:  BCF    20.5
00D6:  MOVF   20,W
00D7:  BSF    03.5
00D8:  MOVWF  07
00D9:  BCF    03.5
00DA:  BSF    07.5
.................... 		} 
00DB:  GOTO   067
.................... 	} 
.................... } 
00DC:  SLEEP

Configuration Fuses:
   Word  1: 20C4   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD NOBROWNOUT NOIESO NOFCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
